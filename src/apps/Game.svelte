<script lang="ts">
  import {createEventDispatcher} from "svelte";
	import wasm, { Dictionary, Feedback } from "../../src-wasm/Cargo.toml";
  import {arrayEq} from "../etc/utils";
  
  let dispatch = createEventDispatcher()
  // wordle table size
  const ROWS = 6;
  const COLS = 5;
  // regular expression for matching a letter
  const REG = /^[A-Z]$/;

  // binding that enables us to return to main menu
  export let menu;
  let game_status: "Pending" | "Won" | "Lost" = "Pending";

  // need to make a ROW by COL matrix for the data table
  let content: string[][] = Array(ROWS).fill(0).map(()=>Array(COLS).fill(''));
  /** contains the feedback for previous guesses. */
  let feedback_arr: Feedback[][] = [];
  
  /** number of letters written down in the current row */
  let letter_nums = 0
  /** number of previous guesses, which also acts as an index into the current row. */
  let guesses = 0
  let streak = 0
  /** generated by web-assembly code. */
  let secret_word: string;
  
  // import wasm code
  let wasm_loaded = false;
  let wasm_exports: Dictionary | null = null;

  async function load() {
		wasm_exports = await wasm({});
    wasm_loaded = true;
    secret_word = wasm_exports.random_word();
    console.log(`[Game] The secret word is ${secret_word}`)
	}
	load();

  // function to remove a single letter
  function del_letter() {
    if (letter_nums > 0) {
      letter_nums--;
      content[guesses][letter_nums] = "";
    }
  }
  
  // Submit the currently written word.
  function submit_word(){

    // return if final guesses have been reached
    if (guesses >= ROWS) {
      console.log(`[Game Error] The game is finished; There are ${ROWS} rows and you ahve guessed ${guesses} times`);
      return;
    } 
    
    // return if not enough letters were written
    if (letter_nums > COLS) {
      console.log(`[Game Error] Only ${letter_nums} letters written, needed ${COLS}`)
      return;
    }

    // turn the text into a lower-case word
    let guess: string = content[guesses].join("").toLowerCase();
    if (!wasm_exports.is_word(guess)) {
      console.log(`[Game Error] The entry ${guess} isn't a valid word.`)
      return;
    }

    // tell the developer that this is a word.
    // it happened in the past that crlf made
    // rust code not work properly.
    console.log(`[Game] ${guess} is a word`)

    // go back to the first column
    letter_nums = 0;
    guesses++;

    // 0 for not found, 1 for exact, 2 for mismatch, (can't transfer an enum from Rust)
    let feedback = wasm_exports.feedback(guess, secret_word)

    // if we win, increase the streak
    if (arrayEq(feedback, [1, 1, 1, 1, 1])) {
      console.log("[Game] You won!");
      dispatch("new_score", {
        guesses,
        date: new Date().toLocaleString(),
      });
      game_status = "Won";
      streak++;
      
    } else {
      if (guesses == ROWS) {
        streak = 0
        console.log("[Game] You lost!")
        game_status = 'Lost'
      }
    }

    feedback_arr.push(feedback);
    feedback_arr = feedback_arr;
  }


  function try_read_key(ev) {
    let key = ev.key.toUpperCase();
    if (REG.test(key) && letter_nums < COLS) {
      content[guesses][letter_nums] = key;
      letter_nums++;
    }
  }

  function handle_key(ev) { 
    // match the keycode
    switch (ev.keyCode) {
      case 8: {
        /* backspace */
        del_letter()
        break;
      }
      case 13: {
        /* enter */

        // submitting a word requires wasm code
        if(!wasm_loaded) {
          console.log("Ignoring keystroke as WASM has not loaded yet.")
          return;
        }
        submit_word()
        break
      }
      default: {
        /* Try to read a key */
        try_read_key(ev)
      }
    }
  }
</script>

<svelte:window on:keydown={handle_key}/>

<h1>GAME</h1>
<table>
  {#each content as row, i}
    <tr>
      {#each row as col, j}
      <td 
        class:green= "{feedback_arr?.[i]?.[j] == 1}"
        class:yellow= "{feedback_arr?.[i]?.[j] == 2}"
        class:red= "{feedback_arr?.[i]?.[j] == 0}"  
      >
        <span class:active="{i == guesses && j == letter_nums - 1}">
          {col}
        </span>
      </td>
      {/each}
    </tr>
  {/each}
  
</table>

<!-- show a button on game completion -->
{#if game_status != "Pending"}
      <p>
        You have {game_status == "Won" ? "won!" : "lost!"} 
        The secret word was <span class="green">{secret_word}</span>!
      </p>
      <button on:click={()=> {menu = "home"}}>
        Main Menu
      </button>
{/if}

<style lang="scss">
  .active {
    color: gold;
  }

  .green {
    color: green;
    background-color: transparent;
  }
  p {
    font-family: monospace;
    font-weight: bold;
    font-size: large;
  }
  button {
		min-width: 250px;
		background-color: cornsilk;
		font-size: 2em;
		font-weight: bold;
		&:hover {
			background-color: blanchedalmond;
		}
	}
  .green {
    background-color: rgb(170, 226, 86);
  }
  .red {
    background-color: rgb(192, 27, 63);
  }
  .yellow {
    background-color: rgb(220, 235, 20);
  }
  table {
    margin-left: auto;
    margin-right: auto;
  }
  td {
    background-color: cornsilk;
    width: 3em;
    height: 3em;
  }
  span {
    background-color: transparent;
    font-size: 2em;
    color: black;
    font-weight: bold;
  }
</style>